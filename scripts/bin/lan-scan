#!/usr/bin/env python3
"""Scan local network and display devices in a table."""

import subprocess
import socket
import re
from concurrent.futures import ThreadPoolExecutor
from pathlib import Path

# Common MAC vendor prefixes (OUI)
VENDORS = {
    "00:1a:79": "MAG/Infomir",
    "b8:f8:53": "Verizon",
    "48:a6:b8": "Sonos",
    "ec:b5:fa": "Philips Hue",
    "dc:a6:32": "Raspberry Pi",
    "1c:57:dc": "Apple",
    "1c:b3:c9": "Apple",
    "58:d3:49": "Apple",
    "20:7d:74": "Apple",
    "bc:7e:8b": "Apple",
    "48:b4:23": "Amazon",
    "90:2b:34": "Galtronics",
}


def get_network_info() -> tuple[str, str, str] | None:
    """Get primary LAN interface, IP, and base network."""
    result = subprocess.run(["ip", "addr", "show"], capture_output=True, text=True)

    for line in result.stdout.splitlines():
        if "inet " in line and "/24" in line and "scope global" in line:
            # Skip virtual interfaces
            if any(x in line for x in ["docker", "br-", "veth", "cali", "tailscale"]):
                continue

            match = re.search(r"inet (\d+\.\d+\.\d+)\.(\d+)/24.*?(\w+)$", line.strip())
            if match:
                base = match.group(1)
                interface = match.group(3)
                return base, interface, f"{base}.{match.group(2)}/24"

    return None


def ping(ip: str) -> None:
    """Send a single ping to populate ARP cache."""
    subprocess.run(
        ["ping", "-c", "1", "-W", "0.1", ip],
        capture_output=True,
    )


def get_arp_table(interface: str) -> dict[str, str]:
    """Read ARP table from /proc/net/arp."""
    arp = {}
    content = Path("/proc/net/arp").read_text()

    for line in content.splitlines()[1:]:  # Skip header
        parts = line.split()
        if len(parts) >= 6:
            ip, _, _, mac, _, iface = parts[:6]
            if iface == interface and mac != "00:00:00:00:00:00":
                arp[ip] = mac

    return arp


def get_hostname(ip: str) -> str:
    """Resolve hostname via DNS."""
    try:
        hostname, _, _ = socket.gethostbyaddr(ip)
        return hostname
    except socket.herror:
        return "-"


def get_vendor(mac: str) -> str:
    """Lookup vendor from MAC prefix."""
    prefix = mac[:8].lower()
    return VENDORS.get(prefix, "-")


def main():
    network = get_network_info()
    if not network:
        print("Error: Could not detect LAN network")
        return 1

    base_ip, interface, cidr = network
    print(f"Scanning {cidr} on {interface}...\n")

    # Ping sweep in parallel
    ips = [f"{base_ip}.{i}" for i in range(1, 255)]
    with ThreadPoolExecutor(max_workers=64) as executor:
        executor.map(ping, ips)

    # Read ARP table
    arp_table = get_arp_table(interface)

    # Resolve hostnames in parallel
    with ThreadPoolExecutor(max_workers=16) as executor:
        hostnames = dict(zip(arp_table.keys(), executor.map(get_hostname, arp_table.keys())))

    # Build results
    results = []
    for ip, mac in sorted(arp_table.items(), key=lambda x: [int(p) for p in x[0].split(".")]):
        hostname = hostnames.get(ip, "-")
        vendor = get_vendor(mac)
        results.append((ip, mac, hostname, vendor))

    # Print table
    print(f"{'IP Address':<16} {'MAC Address':<19} {'Hostname':<25} {'Vendor'}")
    print(f"{'-'*10:<16} {'-'*11:<19} {'-'*8:<25} {'-'*6}")

    for ip, mac, hostname, vendor in results:
        print(f"{ip:<16} {mac:<19} {hostname:<25} {vendor}")

    print(f"\nFound {len(results)} devices")
    return 0


if __name__ == "__main__":
    exit(main())
